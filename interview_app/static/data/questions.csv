topic_id	title	question	answer
1	ООП	Зачем в python используется ключевое слово self?	“Когда мы создаём новый экземпляр класса, мы по сути создаём новый self, то есть новый объект. Под капотом мы при этом не создаём копию всего кода класса целиком где-то там в памяти. У всех экземпляров одного класса он один на всех, иначе нам бы не хватило никакой памяти, да это и не нужно. Когда мы обращаемся к конкретному экземпляру, Python использует в качестве self конкретный экземпляр с именно его конкретными атрибутами.”\n
1	Задача	Как проверить, что один кортеж содержит все элементы другого кортежа?	“Этот вопрос, как и многие другие, не на выдумывание алгоритма перебора, а на знание и умение вовремя применить готовый метод. Не нужно ничего изобретать, не нужно танцевать вокруг элементов кортежа, пытаясь наиболее эффективно перебрать одно через другое. \nСамый простой способ - использовать метод issubset \n small= (1,2,3) \n big = (4, 5, 6, 7, 1, 2, 4, 4, 3) \n set(small).issubset(set(big)) \n>>>True \n p.s. Туда же \n all(x in big for x in small) \n >>>True”
2	Определение	Что такое ORM, где она используется и можно ли без нее обойтись?	“Объектно-реляционное отображение и означает технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования»… т.е. ORM — прослойка между базой данных и кодом который пишет программист, которая позволяет созданые в программе объекты складывать/получать в/из бд. \nПлюсы использования ORM   \n Упрощенный доступ к данным   ORM скрывает сложности работы с SQL и базами данных, предоставляя более простой и понятный интерфейс для работы с данными.\nm Переносимость кода   Использование ORM позволяет писать код, который не зависит от конкретной СУБД, что упрощает перенос приложения на другую базу данных.\n Когда можно обойтись без ORM? \n Если ваше приложение имеет простую структуру данных. \nВ некоторых случаях, особенно когда требуется максимальная производительность или определенные возможности базы данных, напрямую писать SQL-запросы может быть предпочтительным вариантом.”
2	Определение	Primary key, Foreign key	“Primary key (первичный ключ) - это уникальный идентификатор для каждой записи (строки) в таблице базы данных. Он служит для однозначной идентификации каждой записи в таблице. Обычно первичный ключ представляет собой числовое значение или уникальную комбинацию значений полей.\n Foreign key (внешний ключ) - это поле в таблице, которое связывает ее с первичным ключом другой таблицы. Внешний ключ позволяет строить отношения между таблицами.\n Пример   Предположим, у нас есть две таблицы   Пользователи и Заказы. В таблице Пользователи первичным ключом может быть идентификатор пользователя (например, UserID), а в таблице Заказы внешним ключом может быть поле UserID, которое ссылается на первичный ключ (UserID) в таблице Пользователи. Таким образом, каждый заказ в таблице Заказы связан с конкретным пользователем из таблицы Пользователи через внешний ключ.”\n
3	Определение	В чем различия merge vs rebase vs cherry-pick?	“Merge (слияние) используется для объединения изменений из одной ветки в другую.\n - При выполнении merge Git создает новый коммит, который объединяет изменения из двух разных веток, сохраняя историю каждой из них. \n- Это хороший выбор, когда вы хотите сохранить историю всех внесенных изменений и обозначить явное место объединения веток. \nRebase (перебазирование) используется для перемещения текущей ветки на другое место, основанное на другой ветке. \n - При выполнении rebase, Git берет изменения, которые были сделаны в текущей ветке после ее отхода от базовой ветки (обычно это основная ветка), и «перебазирует» эти изменения поверх последнего коммита базовой ветки.\n - Это создает чистую, линейную историю коммитов без лишних слияний, но переписывает историю текущей ветки, что может привести к проблемам, если ветка была опубликована или используется другими разработчиками.\n Cherry-pick (выборочное копирование) используется для применения конкретных коммитов из одной ветки в другую. - При выполнении cherry-pick, вы выбираете определенные коммиты из одной ветки и копируете их в текущую ветку. Это удобно, когда вы хотите включить только определенные изменения из одной ветки в другую, без объединения всей ветки.”\n
4	Определение	В чем отличие 401 и 403 ошибки?	“401 Unauthorized (Неавторизован) и 403 Forbidden (Запрещено) являются HTTP статусами, указывающими на ошибку доступа к ресурсу. \n Ошибка 401 Unauthorized означает, что клиент не предоставил аутентификационных сведений для доступа к запрашиваемому ресурсу.\n Ошибка 403 Forbidden указывает на то, что доступ к запрашиваемому ресурсу запрещен, и клиент не имеет права на его использование. Это может быть связано с ограничениями прав доступа, настройками безопасности или другими ограничениями, установленными на сервере.”
4	Определение	Отличия методов http	HTTP (Hypertext Transfer Protocol) - это протокол, используемый для передачи данных между клиентом и сервером в сети. В HTTP существуют различные методы (или запросы), которые определяют тип операции, выполняемой на ресурсе сервера. \nGET\nИспользуется для получения данных с сервера. Метод безопасен, то есть не должен изменять состояние сервера или ресурсов. \nPOST  \nИспользуется для отправки данных на сервер для обработки. Метод не безопасен, поскольку может изменить состояние сервера или ресурсов (например, создание новой записи на сервере). \nPUT \nИспользуется для обновления или замены существующего ресурса на сервере. Метод идемпотентный, то есть повторные запросы с одинаковыми данными не изменят состояние сервера. \nDELETE  \nИспользуется для удаления ресурса на сервере. Также является идемпотентным методом. \nPATCH  \nИспользуется для частичного обновления ресурса на сервере.Также является идемпотентным методом. \nИдемпотентные методы - это методы в протоколе HTTP, которые можно вызывать несколько раз, и результат будет одинаковым, как если бы метод был вызван только один раз. \n Неидемпотентные методы в протоколе HTTP - это методы, которые могут изменять состояние сервера или ресурсов с каждым их вызовом. Повторный вызов неидемпотентного метода может привести к различным результатам или изменению состояния на сервере. Например, методы POST, PATCH и несуществующий в стандартном наборе метод X не являются идемпотентными. Повторный вызов метода POST может привести к созданию дубликатов ресурсов, а повторный вызов метода PATCH может привести к различным изменениям состояния ресурса в зависимости от того, какие изменения были применены при каждом вызове.”
5	Определение	Middleware	“Middleware в Django - это компонент, который обеспечивает обработку запросов и ответов, позволяет добавлять дополнительную функциональность и обрабатывать запросы и ответы до того, как они достигнут представления (view). Middleware в Django выполняет следующие функции  \nОбработка запросов   Middleware может выполнять действия перед обработкой запроса в представлении. Например, он может проверять авторизацию пользователя, проверять CSRF-токены, выполнять логирование запросов и другие операции, которые должны быть выполнены перед обработкой запроса приложением. \nОбработка ответов   Middleware может также изменять или добавлять информацию в ответ, возвращаемый веб-приложением. Например, он может добавлять заголовки к ответу, устанавливать кэш или изменять содержимое ответа.”\n
5	Определение	Migrations - что такое и как работает.	“Миграции в Django - это механизм, который обеспечивает автоматическое создание и обновление структуры базы данных в соответствии с определенными моделями (models) в Django приложении. Миграции позволяют вам создавать, изменять и удалять таблицы, поля и связи между ними, сохраняя данные, уже содержащиеся в базе данных. При создании или изменении моделей Django генерирует миграционные файлы, которые описывают изменения, необходимые для синхронизации базы данных с определенными моделями. Каждый файл миграции содержит инструкции, такие как создание таблиц, добавление полей или изменение существующих полей.”\n
6	Определение	Кратко расскажите об особенностях, преимуществах и недостатках Flask	“У этого фреймворка небольшой размер исходной кодовой базы, поэтому его называют микрофреймворком. По умолчанию он включает в себя только обработчик запросов и шаблонизатор, а простейшее приложение на Flask может состоять всего из нескольких строк. Разработчики этого фреймворка осознанно хотели сохранить ядро простым, но расширяемым. /nС помощью Flask можно реализовать практически любую задачу   от простого одностраничного сайта до серьёзного проекта с авторизацией, аутентификацией и другими возможностями. Flask подходит для задач, которые подразумевают гибкость в выборе компонентов. Разработчик сам принимает решение, что ему пригодится в работе.  /nУ Flask нет встроенной ORM, но фреймворк совместим со сторонними проектами — SQLAlchemy, PonyORM, Tortoise ORM и другими. Наиболее популярный среди них — SQLAlchemy. /nВо Flask есть интерактивная оболочка.Это по сути обычный интерпретатор Python, который запускается в режиме командной строки и сразу же после запуска импортирует экземпляр приложения Flask.”\n
7	Определение	Кратко расскажите об особенностях, преимуществах и недостатках FastAPI.	“Особенности FastAPI   Автоматическая генерация документации   FastAPI автоматически генерирует интерактивную документацию API на основе аннотаций типов и комментариев к коду, что значительно упрощает разработку и поддержку API. Поддержка асинхронности   FastAPI поддерживает асинхронное программирование с использованием синтаксиса async/await. Это позволяет обрабатывать запросы параллельно и повышает эффективность при работе с внешними сервисами или базами данных. Встроенная валидация и сериализация данных   FastAPI предоставляет интеграцию с пакетом Pydantic для автоматической валидации входных данных, сериализации и десериализации моделей данных, что снижает количество ошибок и упрощает обработку данных. Не подходит для всех случаев   FastAPI может быть излишним для простых веб-приложений или микросервисов с низкой нагрузкой. Относительная новизна   FastAPI является относительно новым фреймворком, поэтому у него может быть меньше комьюнити, чем у Django.”\n
8	Определение	Разница continuous deployment vs continuous delivery	“CI (непрерывная интеграция) — это способ интеграции изменений кода в репозиторий по несколько раз в день. У CD есть два значения   непрерывная доставка автоматизирует интеграцию в то время, как непрерывное развертывание автоматически выпускает финальную сборку для конечных пользователей. Регулярное тестирование в рамках CI/CD уменьшает количество ошибок и дефектов кода.”\n
